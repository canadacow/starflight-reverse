#ifdef SDL
#include <SDL2/SDL.h>
#include <SDL2/SDL_render.h>
#include <atomic>
static SDL_Window *window = NULL;
static SDL_Window *offscreenWindow = NULL;
static SDL_Renderer *renderer  = NULL;
static SDL_Renderer *offscreenRenderer  = NULL;
static SDL_Texture* graphicsTexture = NULL;
static SDL_Texture* offscreenTexture = NULL;
static SDL_Texture* windowTexture = NULL;
static SDL_Texture* textTexture = NULL;

static SDL_AudioDeviceID audioDevice = 0;

#define FREQUENCY 48000 // Samples per second

static double toneInHz = 440.0;

#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <math.h>
#include "graphics.h"

#include <vector>
#include <assert.h>
#include <algorithm>
#include <deque>
#include <memory>
#include <chrono>
#include <thread>
#include <mutex>
#include <semaphore>
#include <unordered_map>
#include <array>

#ifndef SDL
#ifdef __linux__
#include <termios.h>  
#include <unistd.h>   
#include <fcntl.h>    
#endif
#endif

#define TEXT_MODE_WIDTH 640
#define TEXT_MODE_HEIGHT 200

#define GRAPHICS_MODE_WIDTH 160
#define GRAPHICS_MODE_HEIGHT 200
#define GRAPHICS_PAGE_COUNT 2
#define GRAPHICS_MEMORY_ALLOC 65536
static_assert(GRAPHICS_MODE_WIDTH * GRAPHICS_MODE_HEIGHT * GRAPHICS_PAGE_COUNT < GRAPHICS_MEMORY_ALLOC);

static uint32_t WINDOW_WIDTH = 1920;
static uint32_t WINDOW_HEIGHT = 1440;

static uint32_t OFFSCREEN_WINDOW_WIDTH = 960;
static uint32_t OFFSCREEN_WINDOW_HEIGHT = 720;

#define TARGET_RESOLUTION_WIDTH 3840
#define TARGET_RESOLUTION_HEIGHT 2160

#define ROTOSCOPE_MODE_WIDTH  160
#define ROTOSCOPE_MODE_HEIGHT 200

enum SFGraphicsMode
{
    Text = 0,
    Graphics = 1,
};

SFGraphicsMode graphicsMode = Text;

uint32_t graphicsDisplayOffset = 0;// 100 * 160;
std::vector<Rotoscope> rotoscopePixels;
std::vector<uint32_t> graphicsPixels;
std::vector<uint32_t> textPixels;

std::jthread graphicsThread{};
std::binary_semaphore stopSemaphore{0};
std::mutex graphicsRetrace{};

int cursorx = 0;
int cursory = 0;

uint32_t colortable[16] =
{
0x000000, // black
0x0000AA, // blue
0x00AA00, // green
0x00AAAA, // cyan
0xAA0000, // red
0xAA00AA, // magenta
0xAA5500, // brown
0xAAAAAA, // light gray
0x555555, // dark gray
0x5555FF,
0x55FF55,
0x55FFFF,
0xFF5555,
0xFF55FF,
0xFFFF55,
0xFFFFFF,
};

static uint8_t vgafont8[256*8] =
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x7e,0x81,0xa5,0x81,0xbd,0x99,0x81,0x7e,
0x7e,0xff,0xdb,0xff,0xc3,0xe7,0xff,0x7e,
0x6c,0xfe,0xfe,0xfe,0x7c,0x38,0x10,0x00,
0x10,0x38,0x7c,0xfe,0x7c,0x38,0x10,0x00,
0x38,0x7c,0x38,0xfe,0xfe,0x7c,0x38,0x7c,
0x10,0x10,0x38,0x7c,0xfe,0x7c,0x38,0x7c,
0x00,0x00,0x18,0x3c,0x3c,0x18,0x00,0x00,
0xff,0xff,0xe7,0xc3,0xc3,0xe7,0xff,0xff,
0x00,0x3c,0x66,0x42,0x42,0x66,0x3c,0x00,
0xff,0xc3,0x99,0xbd,0xbd,0x99,0xc3,0xff,
0x0f,0x07,0x0f,0x7d,0xcc,0xcc,0xcc,0x78,
0x3c,0x66,0x66,0x66,0x3c,0x18,0x7e,0x18,
0x3f,0x33,0x3f,0x30,0x30,0x70,0xf0,0xe0,
0x7f,0x63,0x7f,0x63,0x63,0x67,0xe6,0xc0,
0x99,0x5a,0x3c,0xe7,0xe7,0x3c,0x5a,0x99,
0x80,0xe0,0xf8,0xfe,0xf8,0xe0,0x80,0x00,
0x02,0x0e,0x3e,0xfe,0x3e,0x0e,0x02,0x00,
0x18,0x3c,0x7e,0x18,0x18,0x7e,0x3c,0x18,
0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x00,
0x7f,0xdb,0xdb,0x7b,0x1b,0x1b,0x1b,0x00,
0x3e,0x63,0x38,0x6c,0x6c,0x38,0xcc,0x78,
0x00,0x00,0x00,0x00,0x7e,0x7e,0x7e,0x00,
0x18,0x3c,0x7e,0x18,0x7e,0x3c,0x18,0xff,
0x18,0x3c,0x7e,0x18,0x18,0x18,0x18,0x00,
0x18,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,
0x00,0x18,0x0c,0xfe,0x0c,0x18,0x00,0x00,
0x00,0x30,0x60,0xfe,0x60,0x30,0x00,0x00,
0x00,0x00,0xc0,0xc0,0xc0,0xfe,0x00,0x00,
0x00,0x24,0x66,0xff,0x66,0x24,0x00,0x00,
0x00,0x18,0x3c,0x7e,0xff,0xff,0x00,0x00,
0x00,0xff,0xff,0x7e,0x3c,0x18,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x30,0x78,0x78,0x30,0x30,0x00,0x30,0x00,
0x6c,0x6c,0x6c,0x00,0x00,0x00,0x00,0x00,
0x6c,0x6c,0xfe,0x6c,0xfe,0x6c,0x6c,0x00,
0x30,0x7c,0xc0,0x78,0x0c,0xf8,0x30,0x00,
0x00,0xc6,0xcc,0x18,0x30,0x66,0xc6,0x00,
0x38,0x6c,0x38,0x76,0xdc,0xcc,0x76,0x00,
0x60,0x60,0xc0,0x00,0x00,0x00,0x00,0x00,
0x18,0x30,0x60,0x60,0x60,0x30,0x18,0x00,
0x60,0x30,0x18,0x18,0x18,0x30,0x60,0x00,
0x00,0x66,0x3c,0xff,0x3c,0x66,0x00,0x00,
0x00,0x30,0x30,0xfc,0x30,0x30,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x60,
0x00,0x00,0x00,0xfc,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,
0x06,0x0c,0x18,0x30,0x60,0xc0,0x80,0x00,
0x7c,0xc6,0xce,0xde,0xf6,0xe6,0x7c,0x00,
0x30,0x70,0x30,0x30,0x30,0x30,0xfc,0x00,
0x78,0xcc,0x0c,0x38,0x60,0xcc,0xfc,0x00,
0x78,0xcc,0x0c,0x38,0x0c,0xcc,0x78,0x00,
0x1c,0x3c,0x6c,0xcc,0xfe,0x0c,0x1e,0x00,
0xfc,0xc0,0xf8,0x0c,0x0c,0xcc,0x78,0x00,
0x38,0x60,0xc0,0xf8,0xcc,0xcc,0x78,0x00,
0xfc,0xcc,0x0c,0x18,0x30,0x30,0x30,0x00,
0x78,0xcc,0xcc,0x78,0xcc,0xcc,0x78,0x00,
0x78,0xcc,0xcc,0x7c,0x0c,0x18,0x70,0x00,
0x00,0x30,0x30,0x00,0x00,0x30,0x30,0x00,
0x00,0x30,0x30,0x00,0x00,0x30,0x30,0x60,
0x18,0x30,0x60,0xc0,0x60,0x30,0x18,0x00,
0x00,0x00,0xfc,0x00,0x00,0xfc,0x00,0x00,
0x60,0x30,0x18,0x0c,0x18,0x30,0x60,0x00,
0x78,0xcc,0x0c,0x18,0x30,0x00,0x30,0x00,
0x7c,0xc6,0xde,0xde,0xde,0xc0,0x78,0x00,
0x30,0x78,0xcc,0xcc,0xfc,0xcc,0xcc,0x00,
0xfc,0x66,0x66,0x7c,0x66,0x66,0xfc,0x00,
0x3c,0x66,0xc0,0xc0,0xc0,0x66,0x3c,0x00,
0xf8,0x6c,0x66,0x66,0x66,0x6c,0xf8,0x00,
0xfe,0x62,0x68,0x78,0x68,0x62,0xfe,0x00,
0xfe,0x62,0x68,0x78,0x68,0x60,0xf0,0x00,
0x3c,0x66,0xc0,0xc0,0xce,0x66,0x3e,0x00,
0xcc,0xcc,0xcc,0xfc,0xcc,0xcc,0xcc,0x00,
0x78,0x30,0x30,0x30,0x30,0x30,0x78,0x00,
0x1e,0x0c,0x0c,0x0c,0xcc,0xcc,0x78,0x00,
0xe6,0x66,0x6c,0x78,0x6c,0x66,0xe6,0x00,
0xf0,0x60,0x60,0x60,0x62,0x66,0xfe,0x00,
0xc6,0xee,0xfe,0xfe,0xd6,0xc6,0xc6,0x00,
0xc6,0xe6,0xf6,0xde,0xce,0xc6,0xc6,0x00,
0x38,0x6c,0xc6,0xc6,0xc6,0x6c,0x38,0x00,
0xfc,0x66,0x66,0x7c,0x60,0x60,0xf0,0x00,
0x78,0xcc,0xcc,0xcc,0xdc,0x78,0x1c,0x00,
0xfc,0x66,0x66,0x7c,0x6c,0x66,0xe6,0x00,
0x78,0xcc,0xe0,0x70,0x1c,0xcc,0x78,0x00,
0xfc,0xb4,0x30,0x30,0x30,0x30,0x78,0x00,
0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xfc,0x00,
0xcc,0xcc,0xcc,0xcc,0xcc,0x78,0x30,0x00,
0xc6,0xc6,0xc6,0xd6,0xfe,0xee,0xc6,0x00,
0xc6,0xc6,0x6c,0x38,0x38,0x6c,0xc6,0x00,
0xcc,0xcc,0xcc,0x78,0x30,0x30,0x78,0x00,
0xfe,0xc6,0x8c,0x18,0x32,0x66,0xfe,0x00,
0x78,0x60,0x60,0x60,0x60,0x60,0x78,0x00,
0xc0,0x60,0x30,0x18,0x0c,0x06,0x02,0x00,
0x78,0x18,0x18,0x18,0x18,0x18,0x78,0x00,
0x10,0x38,0x6c,0xc6,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,
0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x78,0x0c,0x7c,0xcc,0x76,0x00,
0xe0,0x60,0x60,0x7c,0x66,0x66,0xdc,0x00,
0x00,0x00,0x78,0xcc,0xc0,0xcc,0x78,0x00,
0x1c,0x0c,0x0c,0x7c,0xcc,0xcc,0x76,0x00,
0x00,0x00,0x78,0xcc,0xfc,0xc0,0x78,0x00,
0x38,0x6c,0x60,0xf0,0x60,0x60,0xf0,0x00,
0x00,0x00,0x76,0xcc,0xcc,0x7c,0x0c,0xf8,
0xe0,0x60,0x6c,0x76,0x66,0x66,0xe6,0x00,
0x30,0x00,0x70,0x30,0x30,0x30,0x78,0x00,
0x0c,0x00,0x0c,0x0c,0x0c,0xcc,0xcc,0x78,
0xe0,0x60,0x66,0x6c,0x78,0x6c,0xe6,0x00,
0x70,0x30,0x30,0x30,0x30,0x30,0x78,0x00,
0x00,0x00,0xcc,0xfe,0xfe,0xd6,0xc6,0x00,
0x00,0x00,0xf8,0xcc,0xcc,0xcc,0xcc,0x00,
0x00,0x00,0x78,0xcc,0xcc,0xcc,0x78,0x00,
0x00,0x00,0xdc,0x66,0x66,0x7c,0x60,0xf0,
0x00,0x00,0x76,0xcc,0xcc,0x7c,0x0c,0x1e,
0x00,0x00,0xdc,0x76,0x66,0x60,0xf0,0x00,
0x00,0x00,0x7c,0xc0,0x78,0x0c,0xf8,0x00,
0x10,0x30,0x7c,0x30,0x30,0x34,0x18,0x00,
0x00,0x00,0xcc,0xcc,0xcc,0xcc,0x76,0x00,
0x00,0x00,0xcc,0xcc,0xcc,0x78,0x30,0x00,
0x00,0x00,0xc6,0xd6,0xfe,0xfe,0x6c,0x00,
0x00,0x00,0xc6,0x6c,0x38,0x6c,0xc6,0x00,
0x00,0x00,0xcc,0xcc,0xcc,0x7c,0x0c,0xf8,
0x00,0x00,0xfc,0x98,0x30,0x64,0xfc,0x00,
0x1c,0x30,0x30,0xe0,0x30,0x30,0x1c,0x00,
0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00,
0xe0,0x30,0x30,0x1c,0x30,0x30,0xe0,0x00,
0x76,0xdc,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x10,0x38,0x6c,0xc6,0xc6,0xfe,0x00,
0x78,0xcc,0xc0,0xcc,0x78,0x18,0x0c,0x78,
0x00,0xcc,0x00,0xcc,0xcc,0xcc,0x7e,0x00,
0x1c,0x00,0x78,0xcc,0xfc,0xc0,0x78,0x00,
0x7e,0xc3,0x3c,0x06,0x3e,0x66,0x3f,0x00,
0xcc,0x00,0x78,0x0c,0x7c,0xcc,0x7e,0x00,
0xe0,0x00,0x78,0x0c,0x7c,0xcc,0x7e,0x00,
0x30,0x30,0x78,0x0c,0x7c,0xcc,0x7e,0x00,
0x00,0x00,0x78,0xc0,0xc0,0x78,0x0c,0x38,
0x7e,0xc3,0x3c,0x66,0x7e,0x60,0x3c,0x00,
0xcc,0x00,0x78,0xcc,0xfc,0xc0,0x78,0x00,
0xe0,0x00,0x78,0xcc,0xfc,0xc0,0x78,0x00,
0xcc,0x00,0x70,0x30,0x30,0x30,0x78,0x00,
0x7c,0xc6,0x38,0x18,0x18,0x18,0x3c,0x00,
0xe0,0x00,0x70,0x30,0x30,0x30,0x78,0x00,
0xc6,0x38,0x6c,0xc6,0xfe,0xc6,0xc6,0x00,
0x30,0x30,0x00,0x78,0xcc,0xfc,0xcc,0x00,
0x1c,0x00,0xfc,0x60,0x78,0x60,0xfc,0x00,
0x00,0x00,0x7f,0x0c,0x7f,0xcc,0x7f,0x00,
0x3e,0x6c,0xcc,0xfe,0xcc,0xcc,0xce,0x00,
0x78,0xcc,0x00,0x78,0xcc,0xcc,0x78,0x00,
0x00,0xcc,0x00,0x78,0xcc,0xcc,0x78,0x00,
0x00,0xe0,0x00,0x78,0xcc,0xcc,0x78,0x00,
0x78,0xcc,0x00,0xcc,0xcc,0xcc,0x7e,0x00,
0x00,0xe0,0x00,0xcc,0xcc,0xcc,0x7e,0x00,
0x00,0xcc,0x00,0xcc,0xcc,0x7c,0x0c,0xf8,
0xc3,0x18,0x3c,0x66,0x66,0x3c,0x18,0x00,
0xcc,0x00,0xcc,0xcc,0xcc,0xcc,0x78,0x00,
0x18,0x18,0x7e,0xc0,0xc0,0x7e,0x18,0x18,
0x38,0x6c,0x64,0xf0,0x60,0xe6,0xfc,0x00,
0xcc,0xcc,0x78,0xfc,0x30,0xfc,0x30,0x30,
0xf8,0xcc,0xcc,0xfa,0xc6,0xcf,0xc6,0xc7,
0x0e,0x1b,0x18,0x3c,0x18,0x18,0xd8,0x70,
0x1c,0x00,0x78,0x0c,0x7c,0xcc,0x7e,0x00,
0x38,0x00,0x70,0x30,0x30,0x30,0x78,0x00,
0x00,0x1c,0x00,0x78,0xcc,0xcc,0x78,0x00,
0x00,0x1c,0x00,0xcc,0xcc,0xcc,0x7e,0x00,
0x00,0xf8,0x00,0xf8,0xcc,0xcc,0xcc,0x00,
0xfc,0x00,0xcc,0xec,0xfc,0xdc,0xcc,0x00,
0x3c,0x6c,0x6c,0x3e,0x00,0x7e,0x00,0x00,
0x38,0x6c,0x6c,0x38,0x00,0x7c,0x00,0x00,
0x30,0x00,0x30,0x60,0xc0,0xcc,0x78,0x00,
0x00,0x00,0x00,0xfc,0xc0,0xc0,0x00,0x00,
0x00,0x00,0x00,0xfc,0x0c,0x0c,0x00,0x00,
0xc3,0xc6,0xcc,0xde,0x33,0x66,0xcc,0x0f,
0xc3,0xc6,0xcc,0xdb,0x37,0x6f,0xcf,0x03,
0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x00,
0x00,0x33,0x66,0xcc,0x66,0x33,0x00,0x00,
0x00,0xcc,0x66,0x33,0x66,0xcc,0x00,0x00,
0x22,0x88,0x22,0x88,0x22,0x88,0x22,0x88,
0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,
0xdb,0x77,0xdb,0xee,0xdb,0x77,0xdb,0xee,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0xf8,0x18,0x18,0x18,
0x18,0x18,0xf8,0x18,0xf8,0x18,0x18,0x18,
0x36,0x36,0x36,0x36,0xf6,0x36,0x36,0x36,
0x00,0x00,0x00,0x00,0xfe,0x36,0x36,0x36,
0x00,0x00,0xf8,0x18,0xf8,0x18,0x18,0x18,
0x36,0x36,0xf6,0x06,0xf6,0x36,0x36,0x36,
0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
0x00,0x00,0xfe,0x06,0xf6,0x36,0x36,0x36,
0x36,0x36,0xf6,0x06,0xfe,0x00,0x00,0x00,
0x36,0x36,0x36,0x36,0xfe,0x00,0x00,0x00,
0x18,0x18,0xf8,0x18,0xf8,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xf8,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x1f,0x00,0x00,0x00,
0x18,0x18,0x18,0x18,0xff,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xff,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x1f,0x18,0x18,0x18,
0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,
0x18,0x18,0x18,0x18,0xff,0x18,0x18,0x18,
0x18,0x18,0x1f,0x18,0x1f,0x18,0x18,0x18,
0x36,0x36,0x36,0x36,0x37,0x36,0x36,0x36,
0x36,0x36,0x37,0x30,0x3f,0x00,0x00,0x00,
0x00,0x00,0x3f,0x30,0x37,0x36,0x36,0x36,
0x36,0x36,0xf7,0x00,0xff,0x00,0x00,0x00,
0x00,0x00,0xff,0x00,0xf7,0x36,0x36,0x36,
0x36,0x36,0x37,0x30,0x37,0x36,0x36,0x36,
0x00,0x00,0xff,0x00,0xff,0x00,0x00,0x00,
0x36,0x36,0xf7,0x00,0xf7,0x36,0x36,0x36,
0x18,0x18,0xff,0x00,0xff,0x00,0x00,0x00,
0x36,0x36,0x36,0x36,0xff,0x00,0x00,0x00,
0x00,0x00,0xff,0x00,0xff,0x18,0x18,0x18,
0x00,0x00,0x00,0x00,0xff,0x36,0x36,0x36,
0x36,0x36,0x36,0x36,0x3f,0x00,0x00,0x00,
0x18,0x18,0x1f,0x18,0x1f,0x00,0x00,0x00,
0x00,0x00,0x1f,0x18,0x1f,0x18,0x18,0x18,
0x00,0x00,0x00,0x00,0x3f,0x36,0x36,0x36,
0x36,0x36,0x36,0x36,0xff,0x36,0x36,0x36,
0x18,0x18,0xff,0x18,0xff,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0xf8,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x1f,0x18,0x18,0x18,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
0x00,0x00,0x76,0xdc,0xc8,0xdc,0x76,0x00,
0x00,0x78,0xcc,0xf8,0xcc,0xf8,0xc0,0xc0,
0x00,0xfc,0xcc,0xc0,0xc0,0xc0,0xc0,0x00,
0x00,0xfe,0x6c,0x6c,0x6c,0x6c,0x6c,0x00,
0xfc,0xcc,0x60,0x30,0x60,0xcc,0xfc,0x00,
0x00,0x00,0x7e,0xd8,0xd8,0xd8,0x70,0x00,
0x00,0x66,0x66,0x66,0x66,0x7c,0x60,0xc0,
0x00,0x76,0xdc,0x18,0x18,0x18,0x18,0x00,
0xfc,0x30,0x78,0xcc,0xcc,0x78,0x30,0xfc,
0x38,0x6c,0xc6,0xfe,0xc6,0x6c,0x38,0x00,
0x38,0x6c,0xc6,0xc6,0x6c,0x6c,0xee,0x00,
0x1c,0x30,0x18,0x7c,0xcc,0xcc,0x78,0x00,
0x00,0x00,0x7e,0xdb,0xdb,0x7e,0x00,0x00,
0x06,0x0c,0x7e,0xdb,0xdb,0x7e,0x60,0xc0,
0x38,0x60,0xc0,0xf8,0xc0,0x60,0x38,0x00,
0x78,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x00,
0x00,0xfc,0x00,0xfc,0x00,0xfc,0x00,0x00,
0x30,0x30,0xfc,0x30,0x30,0x00,0xfc,0x00,
0x60,0x30,0x18,0x30,0x60,0x00,0xfc,0x00,
0x18,0x30,0x60,0x30,0x18,0x00,0xfc,0x00,
0x0e,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0xd8,0xd8,0x70,
0x30,0x30,0x00,0xfc,0x00,0x30,0x30,0x00,
0x00,0x76,0xdc,0x00,0x76,0xdc,0x00,0x00,
0x38,0x6c,0x6c,0x38,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,
0x0f,0x0c,0x0c,0x0c,0xec,0x6c,0x3c,0x1c,
0x78,0x6c,0x6c,0x6c,0x6c,0x00,0x00,0x00,
0x70,0x18,0x30,0x60,0x78,0x00,0x00,0x00,
0x00,0x00,0x3c,0x3c,0x3c,0x3c,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

class DOSKeyboard {
public:
    // Destructive read equivalent to Int 16 ah = 0
    virtual bool checkForKeyStroke() = 0;
    // Destructive read equivalent to Int 16 ah = 0
    virtual unsigned short getKeyStroke() = 0;

    virtual ~DOSKeyboard() = default;
};

class CLIKeyboard : public DOSKeyboard {
private:
    std::deque<uint16_t> queuedString{};

public:
    CLIKeyboard() = default;

    virtual ~CLIKeyboard() = default;

    bool checkForKeyStroke() override {
        return true;
    }

    unsigned short getKeyStroke() override {
        if(queuedString.empty())
        {
            printf("input: ");
            fflush(stdout);
            int c;
            do {
                c = getchar();
                queuedString.push_back(c);
            } while(c != '\n');
        }

        auto ret = queuedString.front();
        queuedString.pop_front();

        return ret;
    }
};

#ifdef SDL
class SDLKeyboard : public DOSKeyboard {
private:
    std::deque<SDL_Event> eventQueue{};

public:
    SDLKeyboard() {}

    static unsigned short GetKey(int sym)
    {
        if (sym == SDLK_LEFT)
        {
            return 331;
        }
        if (sym == SDLK_RIGHT)
        {
            return 333;
        }
        if (sym == SDLK_UP)
        {
            return 328;
        }
        if (sym == SDLK_DOWN)
        {
            return 336;
        }
        if (sym == SDLK_KP_8)
        {
            return 328;
        }
        if (sym == SDLK_KP_2)
        {
            return 336;
        }
        if (sym == SDLK_KP_4)
        {
            return 331;
        }
        if (sym == SDLK_KP_6)
        {
            return 333;
        }
        if (sym == SDLK_KP_7)
        {
            return 327;
        }
        if (sym == SDLK_KP_9)
        {
            return 329;
        }
        if (sym == SDLK_KP_1)
        {
            return 335;
        }
        if (sym == SDLK_KP_3)
        {
            return 337;
        }

        return sym;
    }

    void update(bool blocking) {

        auto handleEvent = [&](SDL_Event event) -> bool {
            switch (event.type) {
                case SDL_KEYDOWN:
                    if(eventQueue.size() < 4)
                    {
                        eventQueue.push_back(event);
                    }
                    return true;
                    break;
                case SDL_WINDOWEVENT:
                    {
                        if(event.window.event == SDL_WINDOWEVENT_CLOSE)
                        {
                            if(SDL_GetWindowFromID(event.window.windowID) == window)
                            {
                                GraphicsQuit();
                                exit(0);
                            }
                            if(SDL_GetWindowFromID(event.window.windowID) == offscreenWindow)
                            {
                                SDL_DestroyWindow(offscreenWindow);
                                offscreenWindow = nullptr;
                            }
                        }
                    }
                    break;
                case SDL_QUIT:
                    GraphicsQuit();
                    exit(0);
                    break;
                default:
                    break;
            }

            return false;
        };

        if(blocking)
        {
            SDL_Event event;
            for(;;)
            {
                if(SDL_WaitEvent(&event))
                {
                    bool key = handleEvent(event);
                    if(key)
                        break;
                }
                else
                {
                    break;
                }
                std::this_thread::yield();
            }
            
        }
        else
        {
            SDL_Event event;
            if(SDL_PollEvent(&event))
            {
                handleEvent(event);
            }
            std::this_thread::yield();
        }
    }

    // Non-destructive read equivalent to Int 16 ah = 1
    bool checkForKeyStroke() override {
        update(false);
        return !eventQueue.empty();
    }

    // Destructive read equivalent to Int 16 ah = 0
    unsigned short getKeyStroke() override {
        if (eventQueue.empty())
        {
            update(true);
        }

        SDL_Event event = eventQueue.front();
        eventQueue.pop_front();
        return GetKey(event.key.keysym.sym);
    }
};
#endif

static std::unique_ptr<DOSKeyboard> keyboard{};

static bool s_audioPlaying = false;

void play_buffer(void*, unsigned char*, int);

SDL_AudioSpec spec = {
	.freq = FREQUENCY, 
	.format = AUDIO_S16SYS, // Signed 16 bit integer format
	.channels = 1,
	.samples = 512, // The size of each "chunk"
	.callback = play_buffer, // user-defined function that provides the audio data
	.userdata = NULL // an argument to the callback function (we dont need any)
};

// Generate a sine wave
double tone(double hz, unsigned long time) {
	return sin(time * hz * M_PI * 2 / FREQUENCY);
}

// Generate a sawtooth wave
double saw(double hz, unsigned long time) {
	return fmod(time*hz/FREQUENCY, 1)*2-1;
}

// Generate a square wave
double square(double hz, unsigned long time) {
	double sine = tone(hz, time);
	return sine > 0.0 ? 1.0 : -1.0;
}

// This is the function that gets automatically called every time the audio device needs more data
void play_buffer(void* userdata, unsigned char* stream, int len) {
	SDL_memset(stream, spec.silence, len);

    static unsigned long time = 0;
    Sint16 *stream16 = (Sint16*)stream;
    for(int i = 0; i < len/2; i++, time++) {
        if(s_audioPlaying)
        {
            stream16[i] = (Sint16)(square(toneInHz, time) * 5000);
        }
        else
        {
            stream16[i] = spec.silence;
        }
        
    }
}

void BeepOn()
{
    SDL_PauseAudioDevice(audioDevice, 0);
    s_audioPlaying = true;
}

void BeepTone(uint16_t pitFreq)
{
    toneInHz = 1193182.0 / pitFreq;
}

void BeepOff()
{
    s_audioPlaying = false;
}

static int GraphicsInitThread(void *ptr)
{
#ifdef SDL

    SDL_DisplayMode dm;
    if (SDL_GetDesktopDisplayMode(0, &dm) != 0)
    {
        SDL_Log("SDL_GetDesktopDisplayMode failed: %s", SDL_GetError());
    }
    else
    {
        SDL_Log("Desktop display mode: %dx%dpx @ %dhz", dm.w, dm.h, dm.refresh_rate);
    }

    WINDOW_WIDTH = (WINDOW_WIDTH * dm.w) / TARGET_RESOLUTION_WIDTH;
    WINDOW_HEIGHT = (WINDOW_HEIGHT * dm.h) / TARGET_RESOLUTION_HEIGHT;
    OFFSCREEN_WINDOW_WIDTH = (OFFSCREEN_WINDOW_WIDTH * dm.w) / TARGET_RESOLUTION_WIDTH;
    OFFSCREEN_WINDOW_HEIGHT = (OFFSCREEN_WINDOW_HEIGHT * dm.h) / TARGET_RESOLUTION_HEIGHT;

    audioDevice = SDL_OpenAudioDevice(NULL, 0, &spec, NULL, 0);

    window = SDL_CreateWindow("Starflight", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_SHOWN);
    if (window == NULL)
    {
        printf("SDL_CreateWindow Error: %s", SDL_GetError());
        SDL_Quit();
        return 0;
    }  

    renderer = SDL_CreateRenderer(window, -1, 0);
    if (renderer == NULL)
    {
        printf("SDL_CreateRenderer Error: %s", SDL_GetError());
        SDL_Quit();
        return 0;
    }

    offscreenWindow = SDL_CreateWindow("Off Screen Starflight", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, OFFSCREEN_WINDOW_WIDTH, OFFSCREEN_WINDOW_HEIGHT, SDL_WINDOW_SHOWN);
    if (offscreenWindow == NULL)
    {
        printf("SDL_CreateWindow Error: %s", SDL_GetError());
        SDL_Quit();
        return 0;
    }

    offscreenRenderer = SDL_CreateRenderer(offscreenWindow, -1, 0);
    if (offscreenRenderer == NULL)
    {
        printf("SDL_CreateRenderer Error: %s", SDL_GetError());
        SDL_Quit();
        return 0;
    }

    graphicsTexture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STATIC, GRAPHICS_MODE_WIDTH, GRAPHICS_MODE_HEIGHT);
    if (graphicsTexture == NULL)
    {
        printf("SDL_CreateTexture Error: %s", SDL_GetError());
        SDL_Quit();
        return 0;
    }

    windowTexture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STATIC, WINDOW_WIDTH, WINDOW_HEIGHT);
    if (windowTexture == NULL)
    {
        printf("SDL_CreateTexture Error: %s", SDL_GetError());
        SDL_Quit();
        return 0;
    }

    offscreenTexture = SDL_CreateTexture(offscreenRenderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STATIC, GRAPHICS_MODE_WIDTH, GRAPHICS_MODE_HEIGHT);
    if (offscreenTexture == NULL)
    {
        printf("SDL_CreateTexture Error: %s", SDL_GetError());
        SDL_Quit();
        return 0;
    }

    // Create the text mode texture
    textTexture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STATIC, TEXT_MODE_WIDTH, TEXT_MODE_HEIGHT);
    if (textTexture == NULL)
    {
        printf("SDL_CreateTexture Error: %s", SDL_GetError());
        SDL_Quit();
        return 0;
    }

    keyboard = std::make_unique<SDLKeyboard>();
#else
    keyboard = std::make_unique<CLIKeyboard>();
#endif
    graphicsPixels = std::vector<uint32_t>();
    graphicsPixels.resize(GRAPHICS_MEMORY_ALLOC);

    rotoscopePixels = std::vector<Rotoscope>();
    rotoscopePixels.resize(GRAPHICS_MEMORY_ALLOC);

    textPixels = std::vector<uint32_t>();
    textPixels.resize(TEXT_MODE_WIDTH * TEXT_MODE_HEIGHT);

    return 0;
}

void GraphicsInit()
{
#ifdef SDL
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS | SDL_INIT_AUDIO) != 0)
    {
        printf("SDL_Init Error: %s\n", SDL_GetError());
        return;
    }
    FILE* file;
    file = freopen("stdout", "w", stdout); // redirects stdout
    file = freopen("stderr", "w", stderr); // redirects stderr
#endif

    GraphicsInitThread(NULL);
}

struct TextureColor {
    float r, g;
};

template<std::size_t WIDTH, std::size_t HEIGHT>
struct Texture {
    std::array<std::array<TextureColor, WIDTH>, HEIGHT> data;
};

template<std::size_t WIDTH, std::size_t HEIGHT>
TextureColor bilinearSample(const Texture<WIDTH, HEIGHT>& texture, float u, float v) {
    u *= WIDTH - 1;
    v *= HEIGHT - 1;

    int x = (int)u;
    int y = (int)v;
    float u_ratio = u - x;
    float v_ratio = v - y;
    float u_opposite = 1 - u_ratio;
    float v_opposite = 1 - v_ratio;

    TextureColor result;
    result.r = (texture.data[y][x].r * u_opposite + texture.data[y][x+1].r * u_ratio) * v_opposite +
               (texture.data[y+1][x].r * u_opposite  + texture.data[y+1][x+1].r * u_ratio) * v_ratio;
    result.g = (texture.data[y][x].g * u_opposite + texture.data[y][x+1].g * u_ratio) * v_opposite +
               (texture.data[y+1][x].g * u_opposite  + texture.data[y+1][x+1].g * u_ratio) * v_ratio;

    return result;
}

void DoRotoscope(std::vector<uint32_t>& windowData)
{
    Texture<GRAPHICS_MODE_WIDTH, GRAPHICS_MODE_HEIGHT> texture{};
    for(uint32_t y = 0; y < GRAPHICS_MODE_HEIGHT; ++y)
    {
        for(uint32_t x = 0; x < GRAPHICS_MODE_WIDTH; ++x)
        {
            uint32_t srcIndex = y * GRAPHICS_MODE_WIDTH + x;
            auto& roto = rotoscopePixels[srcIndex];

            if(roto.content == TextPixel)
            {
                float i = (float)roto.blt_x / (float)(roto.blt_w - 1);
                float j = (float)roto.blt_y / (float)(roto.blt_h - 1);
                texture.data[y][x] = { i, j };
            }
            else
            {
                texture.data[y][x] = { 0.0f, 0.0f };
            }
        }
    }

    uint32_t index = 0;
    for(uint32_t y = 0; y < WINDOW_HEIGHT; ++y)
    {
        for(uint32_t x = 0; x < WINDOW_WIDTH; ++x)
        {
            // Calculate the corresponding position in the smaller texture
            uint32_t srcX = x * GRAPHICS_MODE_WIDTH / WINDOW_WIDTH;
            uint32_t srcY = y * GRAPHICS_MODE_HEIGHT / WINDOW_HEIGHT;

            // Calculate the index in the smaller texture
            uint32_t srcIndex = srcY * GRAPHICS_MODE_WIDTH + srcX;

            auto& roto = rotoscopePixels[srcIndex];

            // Pull the pixel from the smaller texture
            uint32_t pixel = roto.argb;

            if(roto.content == TextPixel)
            {
                auto sample = bilinearSample(texture, (float)x / (float)WINDOW_WIDTH, (float)y / (float)WINDOW_HEIGHT);

                uint32_t r = static_cast<uint32_t>(sample.r * 255);
                uint32_t g = static_cast<uint32_t>(sample.g * 255);
                uint32_t b = 0;
                uint32_t a = 255;

                pixel = (a << 24) | (r << 16) | (g << 8) | b;
            }

            // Place the pixel in the larger surface
            windowData[index] = pixel;
            ++index;
        }
    }
}

void GraphicsUpdate()
{
#ifdef SDL
    SDL_Texture* currentTexture = NULL;
    uint32_t stride = 0;
    const void* data = nullptr;

    static std::vector<uint32_t> fullRes{};
    if(fullRes.size() == 0)
    {
        fullRes.resize(WINDOW_WIDTH * WINDOW_HEIGHT);
    }

    // Choose the correct texture based on the current mode
    if (graphicsMode == SFGraphicsMode::Graphics)
    {
    #if 0
        currentTexture = graphicsTexture;
        stride = GRAPHICS_MODE_WIDTH;
        data = graphicsPixels.data() + graphicsDisplayOffset;
    #else
        DoRotoscope(fullRes);
        currentTexture = windowTexture;
        stride = WINDOW_WIDTH;
        data = fullRes.data();
    #endif
    }
    else if (graphicsMode == SFGraphicsMode::Text)
    {
        currentTexture = textTexture;
        stride = TEXT_MODE_WIDTH;
        data = textPixels.data();
    }

    SDL_UpdateTexture(currentTexture, NULL, data, stride * sizeof(uint32_t));
    SDL_RenderClear(renderer);
    SDL_RenderCopy(renderer, currentTexture, NULL, NULL);
    SDL_RenderPresent(renderer);
    SDL_PumpEvents();

    if(graphicsMode == SFGraphicsMode::Graphics)
    {
        data = (uint8_t*)graphicsPixels.data(); // + 0x20000;

        stride = GRAPHICS_MODE_WIDTH;

        SDL_UpdateTexture(offscreenTexture, NULL, data, stride * sizeof(uint32_t));
        SDL_RenderClear(offscreenRenderer);
        SDL_RenderCopy(offscreenRenderer, offscreenTexture, NULL, NULL);
        SDL_RenderPresent(offscreenRenderer);
    }
#endif
}

void GraphicsWait()
{
#ifdef SDL
    SDL_Event event;

    while(1)
    {
        SDL_WaitEvent(&event);
        switch (event.type)
        {
            case SDL_QUIT:
                return;
        }
    }
#endif
}

void GraphicsQuit()
{
#ifdef SDL
    if(graphicsThread.joinable())
    {
        stopSemaphore.release();

        graphicsThread.join();
    }

    SDL_DestroyTexture(offscreenTexture);
    SDL_DestroyTexture(graphicsTexture);
    SDL_DestroyTexture(textTexture);
    SDL_DestroyRenderer(offscreenRenderer);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(offscreenWindow);
    SDL_DestroyWindow(window);
#endif
}

void GraphicsSetCursor(int x, int y)
{
    cursorx = x;
    cursory = y;
}

void GraphicsCarriageReturn()
{
    cursorx = 0;
    cursory++;
}

// Font Definition
const uint8_t font4x6 [96][2] = {
 {  0x00  ,  0x00  },   /*SPACE*/
 {  0x49  ,  0x08  },   /*'!'*/
 {  0xb4  ,  0x00  },   /*'"'*/
 {  0xbe  ,  0xf6  },   /*'#'*/
 {  0x7b  ,  0x7a  },   /*'$'*/
 {  0xa5  ,  0x94  },   /*'%'*/
 {  0x55  ,  0xb8  },   /*'&'*/
 {  0x48  ,  0x00  },   /*'''*/
 {  0x29  ,  0x44  },   /*'('*/
 {  0x44  ,  0x2a  },   /*')'*/
 {  0x15  ,  0xa0  },   /*'*'*/
 {  0x0b  ,  0x42  },   /*'+'*/
 {  0x00  ,  0x50  },   /*','*/
 {  0x03  ,  0x02  },   /*'-'*/
 {  0x00  ,  0x08  },   /*'.'*/
 {  0x25  ,  0x90  },   /*'/'*/
 {  0x76  ,  0xba  },   /*'0'*/
 {  0x59  ,  0x5c  },   /*'1'*/
 {  0xc5  ,  0x9e  },   /*'2'*/
 {  0xc5  ,  0x38  },   /*'3'*/
 {  0x92  ,  0xe6  },   /*'4'*/
 {  0xf3  ,  0x3a  },   /*'5'*/
 {  0x73  ,  0xba  },   /*'6'*/
 {  0xe5  ,  0x90  },   /*'7'*/
 {  0x77  ,  0xba  },   /*'8'*/
 {  0x77  ,  0x3a  },   /*'9'*/
 {  0x08  ,  0x40  },   /*':'*/
 {  0x08  ,  0x50  },   /*';'*/
 {  0x2a  ,  0x44  },   /*'<'*/
 {  0x1c  ,  0xe0  },   /*'='*/
 {  0x88  ,  0x52  },   /*'>'*/
 {  0xe5  ,  0x08  },   /*'?'*/
 {  0x56  ,  0x8e  },   /*'@'*/
 {  0x77  ,  0xb6  },   /*'A'*/
 {  0x77  ,  0xb8  },   /*'B'*/
 {  0x72  ,  0x8c  },   /*'C'*/
 {  0xd6  ,  0xba  },   /*'D'*/
 {  0x73  ,  0x9e  },   /*'E'*/
 {  0x73  ,  0x92  },   /*'F'*/
 {  0x72  ,  0xae  },   /*'G'*/
 {  0xb7  ,  0xb6  },   /*'H'*/
 {  0xe9  ,  0x5c  },   /*'I'*/
 {  0x64  ,  0xaa  },   /*'J'*/
 {  0xb7  ,  0xb4  },   /*'K'*/
 {  0x92  ,  0x9c  },   /*'L'*/
 {  0xbe  ,  0xb6  },   /*'M'*/
 {  0xd6  ,  0xb6  },   /*'N'*/
 {  0x56  ,  0xaa  },   /*'O'*/
 {  0xd7  ,  0x92  },   /*'P'*/
 {  0x76  ,  0xee  },   /*'Q'*/
 {  0x77  ,  0xb4  },   /*'R'*/
 {  0x71  ,  0x38  },   /*'S'*/
 {  0xe9  ,  0x48  },   /*'T'*/
 {  0xb6  ,  0xae  },   /*'U'*/
 {  0xb6  ,  0xaa  },   /*'V'*/
 {  0xb6  ,  0xf6  },   /*'W'*/
 {  0xb5  ,  0xb4  },   /*'X'*/
 {  0xb5  ,  0x48  },   /*'Y'*/
 {  0xe5  ,  0x9c  },   /*'Z'*/
 {  0x69  ,  0x4c  },   /*'['*/
 {  0x91  ,  0x24  },   /*'\'*/
 {  0x64  ,  0x2e  },   /*']'*/
 {  0x54  ,  0x00  },   /*'^'*/
 {  0x00  ,  0x1c  },   /*'_'*/
 {  0x44  ,  0x00  },   /*'`'*/
 {  0x0e  ,  0xae  },   /*'a'*/
 {  0x9a  ,  0xba  },   /*'b'*/
 {  0x0e  ,  0x8c  },   /*'c'*/
 {  0x2e  ,  0xae  },   /*'d'*/
 {  0x0e  ,  0xce  },   /*'e'*/
 {  0x56  ,  0xd0  },   /*'f'*/
 {  0x55  ,  0x3B  },   /*'g'*/
 {  0x93  ,  0xb4  },   /*'h'*/
 {  0x41  ,  0x44  },   /*'i'*/
 {  0x41  ,  0x51  },   /*'j'*/
 {  0x97  ,  0xb4  },   /*'k'*/
 {  0x49  ,  0x44  },   /*'l'*/
 {  0x17  ,  0xb6  },   /*'m'*/
 {  0x1a  ,  0xb6  },   /*'n'*/
 {  0x0a  ,  0xaa  },   /*'o'*/
 {  0xd6  ,  0xd3  },   /*'p'*/
 {  0x76  ,  0x67  },   /*'q'*/
 {  0x17  ,  0x90  },   /*'r'*/
 {  0x0f  ,  0x38  },   /*'s'*/
 {  0x9a  ,  0x8c  },   /*'t'*/
 {  0x16  ,  0xae  },   /*'u'*/
 {  0x16  ,  0xba  },   /*'v'*/
 {  0x16  ,  0xf6  },   /*'w'*/
 {  0x15  ,  0xb4  },   /*'x'*/
 {  0xb5  ,  0x2b  },   /*'y'*/
 {  0x1c  ,  0x5e  },   /*'z'*/
 {  0x6b  ,  0x4c  },   /*'{'*/
 {  0x49  ,  0x48  },   /*'|'*/
 {  0xc9  ,  0x5a  },   /*'}'*/
 {  0x54  ,  0x00  },   /*'~'*/
 {  0x56  ,  0xe2  }    /*''*/
};


unsigned char getFontLine(unsigned char data, int line_num) {
  const uint8_t index = (data-32);
  unsigned char pixel = 0;
  if (font4x6[index][1] & 1 == 1) line_num -= 1;
  if (line_num == 0) {
      pixel = (font4x6[index][0]) >> 4;
  } else if (line_num == 1) {
      pixel = (font4x6[index][0]) >> 1;
  } else if (line_num == 2) { 
      // Split over 2 bytes
      return (((font4x6[index][0]) & 0x03) << 2) | (((font4x6[index][1]) & 0x02));
  } else if (line_num == 3) {
      pixel = (font4x6[index][1]) >> 4;
  } else if (line_num == 4) {
      pixel = (font4x6[index][1]) >> 1;
  }
  return pixel & 0xE;
}

void GraphicsChar(unsigned char s)
{
    if(graphicsMode == Text)
    {
        for(int jj=0; jj<8; jj++)
        {
            int offset = ((int)s)*8 + jj;
            for(int ii=0; ii<8; ii++)
            {
                int color = 0;
                if ((vgafont8[offset]) & (1<<(7-ii)))
                {
                    color = 0xFFFFFFFF;
                }

                textPixels[(cursory*8+jj) * TEXT_MODE_WIDTH + (cursorx*8+ii)] = color;
            }
        }
    }
    else
    {
        for(int jj=0; jj<6; jj++)
        {
            unsigned char line = getFontLine(s, jj);
            for(int ii=0; ii<4; ii++)
            {
                int color = 0;
                if ((line) & (1<<(3-ii)))
                {
                    color = 0xFFFFFFFF;
                }
                graphicsPixels[(cursory*6+jj) * GRAPHICS_MODE_WIDTH + (cursorx*4+ii)] = color;
            }
        }
    }

    cursorx++;
    if (cursorx >=80)
    {
        GraphicsCarriageReturn();
    }
}

void GraphicsText(char *s, int n)
{
    for(int i=0; i<n; i++)
    {
        GraphicsChar(s[i]);
    }
    //GraphicsUpdate();
}

// 0 = text, 1 = ega graphics
void GraphicsMode(int mode)
{
    if(graphicsThread.joinable())
    {
        stopSemaphore.release();

        graphicsThread.join();
    }

    graphicsMode = (SFGraphicsMode)mode;

    std::fill(graphicsPixels.begin(), graphicsPixels.end(), 0);
    std::fill(textPixels.begin(), textPixels.end(), 0);
    std::fill(rotoscopePixels.begin(), rotoscopePixels.end(), ClearPixel);

    graphicsThread = std::jthread([]{
        while(!stopSemaphore.try_acquire()) {
            constexpr std::chrono::nanoseconds scanout_duration = std::chrono::nanoseconds(13340000); // 80% of 1/60th of a second
            constexpr std::chrono::nanoseconds retrace_duration = std::chrono::nanoseconds(3330000); // 20% of 1/60th of a second
            {
                std::lock_guard<std::mutex> lg(graphicsRetrace);
                GraphicsUpdate();

                std::this_thread::sleep_for(scanout_duration);
            }
            std::this_thread::sleep_for(retrace_duration);
        }
    });
}

void WaitForVBlank()
{
    graphicsRetrace.lock();
    graphicsRetrace.unlock();
}

void GraphicsClear(int color, uint32_t offset, int byteCount)
{
    uint32_t dest = (uint32_t)offset;

    dest <<= 4; // Convert to linear addres
    dest -= 0xa0000; // Subtract from EGA page
    dest *= 4; // Convert to our SDL memory linear address

    uint32_t destOffset = 0;

    auto c = colortable[color&0xF];

    byteCount = 0x2000;

    for(uint32_t i = 0; i < byteCount * 4; ++i)
    {
        graphicsPixels[dest + destOffset + i] = c;
        rotoscopePixels[dest + destOffset + i] = ClearPixel;
    }
}

void GraphicsCopyLine(uint16_t sourceSeg, uint16_t destSeg, uint16_t si, uint16_t di, uint16_t count)
{
    uint32_t src = (uint32_t)sourceSeg;
    uint32_t dest = (uint32_t)destSeg;

    src <<= 4; // Convert to linear addres
    src -= 0xa0000; // Subtract from EGA page
    src *= 4; // Convert to our SDL memory linear address

    dest <<= 4; // Convert to linear addres
    dest -= 0xa0000; // Subtract from EGA page
    dest *= 4; // Convert to our SDL memory linear address

    uint32_t srcOffset = (uint32_t)si * 4;
    uint32_t destOffset = (uint32_t)di * 4;

    for(uint32_t i = 0; i < count * 4; ++i)
    {
        graphicsPixels[dest + destOffset + i] = graphicsPixels[src + srcOffset + i];
        rotoscopePixels[dest + destOffset + i] = rotoscopePixels[src + srcOffset + i];
    }
}

uint8_t GraphicsPeek(int x, int y, uint32_t offset, Rotoscope* pc)
{
    auto pixel = GraphicsPeekDirect(x, y, offset, pc);

    auto it = std::find(std::begin(colortable), std::end(colortable), pixel);
    assert(it != std::end(colortable));
    return std::distance(std::begin(colortable), it);
}

uint32_t GraphicsPeekDirect(int x, int y, uint32_t offset, Rotoscope* pc)
{
    if(offset == 0)
    {
        assert(false);
        offset = 0xa000;
    }

    offset <<= 4; // Convert to linear addres
    offset -= 0xa0000; // Subtract from EGA page
    offset *= 4; // Convert to our SDL memory linear address

    y = 199 - y;

    if(x < 0 || x >= GRAPHICS_MODE_WIDTH || y < 0 || y >= GRAPHICS_MODE_HEIGHT)
    {
        return colortable[0];
    }

    if(pc)
    {
        *pc = rotoscopePixels[y * GRAPHICS_MODE_WIDTH + x + offset];
    }

    return graphicsPixels[y * GRAPHICS_MODE_WIDTH + x + offset];
}

void GraphicsPixelDirect(int x, int y, uint32_t color, uint32_t offset, Rotoscope pc)
{
    if(offset == 0)
    {
        assert(false);
        offset = 0xa000;
    }

    offset <<= 4; // Convert to linear addres
    offset -= 0xa0000; // Subtract from EGA page
    offset *= 4; // Conver to our SDL memory linear address

    y = 199 - y;

    if(x < 0 || x >= GRAPHICS_MODE_WIDTH || y < 0 || y >= GRAPHICS_MODE_HEIGHT)
    {
        return;
    }

    pc.argb = color;
    rotoscopePixels[y * GRAPHICS_MODE_WIDTH + x + offset] = pc;

    graphicsPixels[y * GRAPHICS_MODE_WIDTH + x + offset] = color;
}

void GraphicsLine(int x1, int y1, int x2, int y2, int color, int xormode, uint32_t offset)
{
    float x = x1;
    float y = y1;
    float dx = (x2 - x1);
    float dy = (y2 - y1);
    int n = fabs(dx);
    if (fabs(dy) > n) n = fabs(dy);
    if (n == 0) return;
    dx /= n;
    dy /= n;

    Rotoscope rs{};
    rs.content = LinePixel;
    rs.lineData.x0 = x1;
    rs.lineData.x1 = x2;
    rs.lineData.y0 = y1;
    rs.lineData.y1 = y2;

    for(int i=0; i<=n; i++)
    {
        rs.lineData.n = i;

        GraphicsPixel(x, y, color, offset, rs);
        x += dx;
        y += dy;
    }
}

void GraphicsPixel(int x, int y, int color, uint32_t offset, Rotoscope pc)
{
    pc.EGAcolor = color & 0xf;
    GraphicsPixelDirect(x, y, colortable[color&0xF], offset, pc);
}

std::unordered_map<char, int> font1_table = {
    {' ', 0x0000}, {'!', 0x4904}, {'"', 0xB400}, {'#', 0xFFFF},
    {'$', 0xF45E}, {'%', 0xA54A}, {'&', 0x0000}, {'\'', 0x4800},
    {'[', 0x2922}, {']', 0x8928}, {'*', 0x1550}, {'+', 0x0BA0},
    {',', 0x0128}, {'-', 0x0380}, {'.', 0x0004}, {'/', 0x2548},
    {'0', 0xF6DE}, {'1', 0x4924}, {'2', 0xE7CE}, {'3', 0xE59E},
    {'4', 0xB792}, {'5', 0xF39E}, {'6', 0xD3DE}, {'7', 0xE524},
    {'8', 0xF7DE}, {'9', 0xF792}, {':', 0x0820}, {';', 0x0828},
    {'<', 0x2A22}, {'=', 0x1C70}, {'>', 0x88A8}, {'?', 0xE584},
    {'@', 0xFFCE}, {'A', 0x57DA}, {'B', 0xD75C}, {'C', 0x7246},
    {'D', 0xD6DC}, {'E', 0xF34E}, {'F', 0xF348}, {'G', 0x7256},
    {'H', 0xB7DA}, {'I', 0xE92E}, {'J', 0x24DE}, {'K', 0xB75A},
    {'L', 0x924E}, {'M', 0xBFDA}, {'N', 0xBFFA}, {'O', 0x56D4},
    {'P', 0xF7C8}, {'Q', 0xF7A6}, {'R', 0xF7EA}, {'S', 0x739C},
    {'T', 0xE924}, {'U', 0xB6DE}, {'V', 0xB6D4}, {'W', 0xB7FA},
    {'X', 0xB55A}, {'Y', 0xB7A4}, {'Z', 0xE54E}
};

std::unordered_map<char, std::array<uint16_t, 3>> font2_table = {
    {' ', {0x0000, 0x0000, 0x0000}}, {'!', {0x0000, 0x0000, 0x0000}},
    {'"', {0x0000, 0x0000, 0x0000}}, {'#', {0x0000, 0x0000, 0x0000}},
    {'$', {0x0000, 0x0000, 0x0000}}, {'%', {0x0000, 0x0000, 0x0000}},
    {'&', {0x0000, 0x0000, 0x0000}}, {'\'', {0x6F00, 0x0000, 0x0000}},
    {'[', {0x0000, 0x0000, 0x0000}}, {']', {0x0000, 0x0000, 0x0000}},
    {'*', {0x0000, 0x0000, 0x0000}}, {'+', {0x0000, 0x0000, 0x0000}},
    {',', {0x0006, 0xF000, 0x0000}}, {'-', {0x0070, 0x0000, 0x0000}},
    {'.', {0x0200, 0x0000, 0x0000}}, {'/', {0x0000, 0x0000, 0x0000}},
    {'0', {0x76F7, 0xBDED, 0xC000}}, {'1', {0x6718, 0xC633, 0xC000}},
    {'2', {0x76C6, 0x6663, 0xE000}}, {'3', {0x76C6, 0x61ED, 0xC000}},
    {'4', {0x35AD, 0x6F98, 0xC000}}, {'5', {0xFE31, 0xE1ED, 0xC000}},
    {'6', {0x76F1, 0xEDED, 0xC000}}, {'7', {0xFEC6, 0x6631, 0x8000}},
    {'8', {0x76F6, 0xEDED, 0xC000}}, {'9', {0x76F6, 0xF1ED, 0xC000}},
    {':', {0x1400, 0x0000, 0x0000}}, {';', {0x0000, 0x0000, 0x0000}},
    {'<', {0x0000, 0x0000, 0x0000}}, {'=', {0x0000, 0x0000, 0x0000}},
    {'>', {0x0000, 0x0000, 0x0000}}, {'?', {0x0000, 0x0000, 0x0000}},
    {'@', {0x0000, 0x0000, 0x0000}}, {'A', {0x3673, 0x9FE7, 0x2000}},
    {'B', {0xEDDE, 0xDDE7, 0x0000}}, {'C', {0x34CC, 0xC430, 0x0000}},
    {'D', {0xEDDD, 0xDDE0, 0x0000}}, {'E', {0xFCCE, 0xCCF0, 0x0000}},
    {'F', {0xFCCE, 0xCCC0, 0x0000}}, {'G', {0x3231, 0x8DA4, 0xC000}},
    {'H', {0xCE73, 0xFCE7, 0x2000}}, {'I', {0xF666, 0x66F0, 0x0000}},
    {'J', {0x3333, 0x3BF0, 0x0000}}, {'K', {0xDDDD, 0xEDD0, 0x0000}},
    {'L', {0xCCCC, 0xCCF0, 0x0000}}, {'M', {0xC71E, 0xF5C7, 0x1C40}},
    {'N', {0xCE7B, 0xBCE7, 0x3900}}, {'O', {0x3273, 0x9CE5, 0xC000}},
    {'P', {0xFDDD, 0xFCC0, 0x0000}}, {'Q', {0x312C, 0xB2D9, 0x2340}},
    {'R', {0xFDDD, 0xEDD0, 0x0000}}, {'S', {0x7CC6, 0x33E0, 0x0000}},
    {'T', {0xF666, 0x6660, 0x0000}}, {'U', {0xCE73, 0x9CE7, 0xE000}},
    {'V', {0xCE73, 0x9CE4, 0xC000}}, {'W', {0xC71C, 0x71D7, 0xF280}},
    {'X', {0xDDD2, 0xDDD0, 0x0000}}, {'Y', {0xDDDD, 0xF660, 0x0000}},
    {'Z', {0xF324, 0xCCF0, 0x0000}}
};

#include <unordered_map>

std::unordered_map<char, std::array<int, 4>> font3_table = {
    {'A', {0x3673, 0x9CFF, 0x39C8, 0x0000}},
    {'B', {0xEDDD, 0xEDDD, 0xE000, 0x0000}},
    {'C', {0x34CC, 0xCCC4, 0x3000, 0x0000}},
    {'D', {0xEDDD, 0xDDDD, 0xE000, 0x0000}},
    {'E', {0xFCCC, 0xECCC, 0xF000, 0x0000}},
    {'F', {0xFCCC, 0xECCC, 0xC000, 0x0000}},
    {'G', {0x3231, 0x8C6F, 0x2930, 0x0000}},
    {'H', {0xCE73, 0x9FE7, 0x39C8, 0x0000}},
    {'I', {0xF666, 0x6666, 0xF000, 0x0000}},
    {'J', {0x3333, 0x333B, 0xF000, 0x0000}},
    {'K', {0xDDDD, 0xDEDD, 0xD000, 0x0000}},
    {'L', {0xCCCC, 0xCCCC, 0xF000, 0x0000}},
    {'M', {0xC71E, 0xF5C7, 0x1C71, 0xC400}},
    {'N', {0xCE7B, 0xBCE7, 0x39C8, 0x0000}},
    {'O', {0x3273, 0x9CE7, 0x2930, 0x0000}},
    {'P', {0xFDDD, 0xDFCC, 0xC000, 0x0000}},
    {'Q', {0x312C, 0xB2CB, 0x2D92, 0x3400}},
    {'R', {0xFDDD, 0xDFED, 0xD000, 0x0000}},
    {'S', {0x7CCC, 0x6333, 0xE000, 0x0000}},
    {'T', {0xF666, 0x6666, 0x6000, 0x0000}},
    {'U', {0xCE73, 0x9CE7, 0x39F8, 0x0000}},
    {'V', {0xCE73, 0x9CE7, 0x3930, 0x0000}},
    {'W', {0xC71C, 0x71C7, 0x1D7A, 0x2800}},
    {'X', {0xDDDD, 0x2DDD, 0xD000, 0x0000}},
    {'Y', {0xDDDD, 0xDF66, 0x6000, 0x0000}},
    {'Z', {0xF332, 0x4CCC, 0xF000, 0x0000}}
};

std::unordered_map<char, int> char_width_table = {
    {' ', 4}, {'!', 4}, {'"', 4}, {'#', 4},
    {'$', 4}, {'%', 4}, {'&', 5}, {'\'', 3},
    {'[', 4}, {']', 4}, {'*', 4}, {'+', 4},
    {',', 3}, {'-', 3}, {'.', 1}, {'/', 4},
    {'0', 5}, {'1', 5}, {'2', 5}, {'3', 5},
    {'4', 5}, {'5', 5}, {'6', 5}, {'7', 5},
    {'8', 5}, {'9', 5}, {':', 1}, {';', 1},
    {'<', 4}, {'=', 4}, {'>', 4}, {'?', 4},
    {'@', 4}, {'A', 5}, {'B', 4}, {'C', 4},
    {'D', 4}, {'E', 4}, {'F', 4}, {'G', 5},
    {'H', 5}, {'I', 4}, {'J', 4}, {'K', 4},
    {'L', 4}, {'M', 6}, {'N', 5}, {'O', 5},
    {'P', 4}, {'Q', 6}, {'R', 4}, {'S', 4},
    {'T', 4}, {'U', 5}, {'V', 5}, {'W', 6},
    {'X', 4}, {'Y', 4}, {'Z', 4}
};

int16_t GraphicsFONT(uint16_t num, uint32_t character, int x1, int y1, int color, int xormode, uint32_t offset)
{
    char c = (char)character;

    Rotoscope rs{};

    rs.content = TextPixel;
    rs.textData.character = c;
    rs.textData.fontNum = num;

    switch(num)
    {
        case 1:
        {
            auto width = 3;
            auto image = font1_table[c];
            rs.textData.fontWidth = width;
            rs.textData.fontHeight = 5;

            GraphicsBLT(x1, y1, 5, width, (const char*)&image, color, xormode, offset, rs);

            return width;
        }
        case 2:
        {
            auto width = char_width_table[c];
            auto image = font2_table[c].data();
            rs.textData.fontWidth = width;
            rs.textData.fontHeight = 7;

            GraphicsBLT(x1, y1, 7, width, (const char*)image, color, xormode, offset, rs);

            return width;
        }
        case 3:
        {
            auto width = char_width_table[c];
            auto image = font3_table[c].data();
            rs.textData.fontWidth = width;
            rs.textData.fontHeight = 9;

            GraphicsBLT(x1, y1, 9, width, (const char*)image, color, xormode, offset, rs);

            return width;            
        }
        default:
            assert(false);
            break;
    }

    assert(false);
    return 1;
}

void GraphicsBLT(int x1, int y1, int h, int w, const char* image, int color, int xormode, uint32_t offset, Rotoscope pc)
{
    auto img = (const short int*)image;
    int n = 0;

    uint16_t xoffset = 0;
    uint16_t yoffset = 0;

    pc.blt_w = w;
    pc.blt_h = h;

    for(int y=y1; y>y1-h; y--)
    {
        xoffset = 0;

        for(int x=x1; x<x1+w; x++)
        {
            int x0 = x;
            int y0 = y;

            bool hasPixel = false;
            auto src = GraphicsPeek(x0, y0, offset);

            pc.blt_x = xoffset;
            pc.blt_y = yoffset;

            if(pc.content == TextPixel)
            {
                pc.textData.bgColor = src;
            }

            if ((*img) & (1<<(15-n)))
            {
                if(xormode) {
                    auto xored = src ^ (color&0xF);
                    GraphicsPixel(x0, y0, xored, offset, pc);
                }
                else
                {
                    GraphicsPixel(x0, y0, color, offset, pc);
                }
            }
            else
            {
                GraphicsPixel(x0, y0, src, offset, pc);
            }
            
            n++;
            if (n == 16)
            {
                n = 0;
                img++;
            }

            ++xoffset;
        }

        ++yoffset;
    }
}

bool GraphicsHasKey()
{
    return keyboard->checkForKeyStroke();
}

uint16_t GraphicsGetKey()
{
    return keyboard->getKeyStroke();
}

void GraphicsSave(char *filename)
{
  FILE *file = fopen(filename, "w");
  if (file == NULL) {
      fprintf(stderr, "Error: Cannot write file\n");
      exit(1);
  }
  printf("Store image %s\n", filename);

  fprintf(file, "P3\n");
  fprintf(file, "%i %i\n", GRAPHICS_MODE_WIDTH, GRAPHICS_MODE_HEIGHT);
  fprintf(file, "255\n");

  for(int j=0; j<GRAPHICS_MODE_HEIGHT; j++)
  {
      for(int i=0; i<GRAPHICS_MODE_WIDTH; i++)
      {
          int c = graphicsPixels[j * GRAPHICS_MODE_WIDTH + i];
          fprintf(file, "%i %i %i ", (c>>16)&0xFF, (c>>8)&0xFF, (c>>0)&0xFF);
      }
      fprintf(file, "\n");
  }
  fclose(file);
}

