// GLSL Compute Shader
#version 450

#extension GL_GOOGLE_include_directive : enable

layout(local_size_x = 32, local_size_y = 32) in;

#define Icon_Other  0
#define Icon_Sun    1
#define Icon_Planet 2
#define Icon_Nebula 3

struct Icon {
    uint isActive;
    int x;
    int y;
    int screenX;

    int screenY;
    int bltX;
    int bltY;
    uint id;

    uint clr;
    uint icon_type;
    int planet_to_sunX;
    int planet_to_sunY;

    uint planetIndex;
};

// Equivalent of TextData struct
struct TextData {
    uint character;
    uint xormode;
    uint fontNum;
};

// Equivalent of LineData struct
struct LineData {
    uint x0;
    uint y0;
    uint x1;
    uint y1;
    uint n;
    uint total;
};

struct RunBitData {
    uint tag;
};

// Equivalent of Rotoscope struct
struct Rotoscope {
    uint content;
    uint EGAcolor;
    uint argb;
    int blt_x;
    int blt_y;
    int blt_w;
    int blt_h;
    uint bgColor;
    uint fgColor;
    TextData textData;
    LineData lineData;
    RunBitData runBitData;
    uint navMask;
    uint chromaKey;
};

layout(rgba8, binding = 0) writeonly uniform image2D imgOutput;

layout(std430, binding = 1) buffer RotoBuffer {
    Rotoscope rotoPixels[];
};

layout(binding = 2) uniform sampler2D ShipTexture;
layout(binding = 3) uniform sampler2DArray PlanetTextures;

layout(binding = 4) uniform UniformBlock {
    int GRAPHICS_MODE_WIDTH;
    int GRAPHICS_MODE_HEIGHT;
    int WINDOW_WIDTH;
    int WINDOW_HEIGHT;
    uint useRotoscope;
    uint useEGA;
    float iTime;
    float worldX;
    float worldY;
    float heading;
    float deadX;
    float deadY;
    // V= CONTEXT-ID#   ( 0=planet surface, 1=orbit, 2=system)         
    // (3 = hyperspace, 4 = encounter, 5 = starport)
    uint game_context; 
    uint alienVar1;
    float screenX;
    float screenY;
    float adjust;
    float planetSize;

    float orbitCamX;
    float orbitCamY;
    float orbitCamZ;

    float nebulaBase;
    float nebulaMultiplier;

    uint orbitMask;

} uniforms;

layout(binding = 5) uniform IconBlock {
    Icon icons[1024];
};

#include "tables.h"
#include "noise.h"
#include "distance.h"
#include "hyperspace_stars.h"
#include "starburst.h"
#include "nebula.h"
#include "sun.h"
#include "planet.h"

#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))
#define pi 3.14159265359

float rr(vec2 uv, float halfExtent, float borderRadius, float anim)
{
    halfExtent += sin(uniforms.iTime * 3.) * .05 * anim;
    return smoothstep(.02, .01, 
                      length(max(abs(uv) - halfExtent, 0.)) - borderRadius);
}

float outerNotch(vec2 uv, float angle) 
{
    const float notchSize = .045;
    const float skew = 1.3;
    uv *= rot(angle);
    uv.y -= .55 + sin(uniforms.iTime * 6.) * .095;
    uv.x /= ((uv.y + notchSize) / (2. * notchSize)) * (skew - 1.) + 1.;
    uv.y /= 2.75;
    return smoothstep(.018, .01, length(max(abs(uv) - notchSize, 0.)));
}

vec4 drawReticle(vec2 uv)
{
    float inner = rr(uv, .18, .02, 1.) * (1. - rr(uv, .12, .02, 1.));
    float dawt = rr(uv, .03, .02, 0.);
    float notch = outerNotch(uv, 0.) + outerNotch(uv, pi / 2.)
        + outerNotch(uv, pi) + outerNotch(uv, 1.5 * pi);
    vec3 frag = (notch + dawt + inner + rr(uv, .35, .05, 1.) * (1. - rr(uv, .275, .05, 1.))
        * step(.15, min(abs(uv.x), abs(uv.y)))) * vec3(0., 1., 0.);

    float luminosity = 0.2126 * frag.r + 0.7152 * frag.g + 0.0722 * frag.b;
    float alpha = smoothstep(0.0, 1.0, luminosity);

    return vec4(frag, alpha);
}

vec4 DrawStarmapPixel(vec2 uv) {
    vec4 pixel = vec4(0.);

    vec4 fragColor;
    vec2 sub;

    float iTime = uniforms.iTime;

    vec2 normalizedCoords = uv / vec2(imageSize(imgOutput));

    vec2 pixelPos = vec2(uniforms.worldX, uniforms.worldY) + (normalizedCoords * vec2(uniforms.screenX, uniforms.screenY));

    vec4 starPixel = vec4(0.);
    vec4 sunPixel = vec4(0.);
    vec4 iconPixel = vec4(0.);
    vec4 shipPixel = vec4(0.);
    vec4 nebulaPixel = vec4(0.);
    vec4 reticlePixel = vec4(0.);

    bool hasNebula = false;

    for(int i = 0; i < 1024; i++) {
        Icon icon = icons[i];

        if(icon.isActive == 0)
            continue;

        vec2 iconPos = vec2(float(icon.x), float(icon.y));

        if(icon.id >= 51 && icon.id <= 91) 
        {
            float basesize = 8.0f * float(icon.id - 50);

            if(icon.icon_type == Icon_Nebula)
            {
                if(calculateDistanceWorldAspect(iconPos, pixelPos) < basesize) 
                {
                    nebulaPixel = vec4(0.2, 0.56, 0.89, 1.0);
                    hasNebula = true;
                }
            }
        }
        else
        {
            float distance = 4.5;

            switch(icon.id) {
                case 253:
                    {
                        float circ = calculateDistanceWorldAspect(iconPos, pixelPos);
                        if(circ < (distance - 1.5)) {
                            sunPixel = vec4(colortable[icon.clr & 0xf].rgb, 1.0);
                        }
                        else if(circ < distance) {
                            sunPixel = vec4(1.);
                        }
                    }
                    break;
                case 254: // Invisible icon (Encounter hit testing?)
                    // NOP
                    break;
                case 255: // Flux icon
                    // TBD
                    break;
                default:
                    break;
            }

        }
    }

    vec2 recticle = vec2(uniforms.deadX, uniforms.deadY);

    if(calculateBoundingBoxDistance(recticle, pixelPos) < 32.0)
    {
        vec2 normUV = calculateNormalizedUVWorldAspect(recticle, pixelPos, 32.0) - vec2(0.5, 0.5);
        reticlePixel = drawReticle(normUV);
    }

    if(hasNebula)
    {
        pixel = nebulaPixel;
    }
    else
    {
        pixel += starPixel;
        pixel += sunPixel;
    }

    pixel = shipPixel + (pixel * (1 - shipPixel.a));
    pixel = reticlePixel + (pixel * (1 - reticlePixel.a));
    
    return pixel;
}

void main() {
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(pixelPos);

    vec4 pixel = DrawStarmapPixel(uv);

    // Place the pixel in the larger surface
    imageStore(imgOutput, pixelPos, pixel);
}
