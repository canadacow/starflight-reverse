// GLSL Compute Shader
#version 450

#extension GL_GOOGLE_include_directive : enable

layout(local_size_x = 4, local_size_y = 4) in;

struct Icon {
    uint isActive;
    int x;
    int y;
    int screenX;

    int screenY;
    int bltX;
    int bltY;
    uint id;

    uint clr;
    uint icon_type;
    int planet_to_sunX;
    int planet_to_sunY;

    uint planetIndex;
};

// Equivalent of TextData struct
struct TextData {
    uint character;
    uint xormode;
    uint fontNum;
};

// Equivalent of LineData struct
struct LineData {
    uint x0;
    uint y0;
    uint x1;
    uint y1;
    uint n;
    uint total;
};

struct RunBitData {
    uint tag;
};

// Equivalent of Rotoscope struct
struct Rotoscope {
    uint content;
    uint EGAcolor;
    uint argb;
    int blt_x;
    int blt_y;
    int blt_w;
    int blt_h;
    uint bgColor;
    uint fgColor;
    TextData textData;
    LineData lineData;
    RunBitData runBitData;
};

layout(rgba8, binding = 0) writeonly uniform image2D imgOutput;

layout(std430, binding = 1) buffer RotoBuffer {
    Rotoscope rotoPixels[];
};

layout(binding = 2) uniform sampler2D FONT1Texture;
layout(binding = 3) uniform sampler2D FONT2Texture;
layout(binding = 4) uniform sampler2D FONT3Texture;
layout(binding = 5) uniform sampler2D LOGO1Texture;
layout(binding = 6) uniform sampler2D LOGO2Texture;
layout(binding = 7) uniform sampler2D PORTPICTexture;
layout(binding = 8) uniform sampler2D RACEDOSATLASTexture;
layout(binding = 9) uniform sampler2D ShipTexture;
layout(binding = 10) uniform sampler2DArray PlanetTextures;
layout(binding = 11) uniform sampler2D AlienColorTexture;
layout(binding = 12) uniform sampler2D AlienDepthTexture;
layout(binding = 13) uniform sampler2D AlienBackgroundTexture;

layout(binding = 14) uniform UniformBlock {
    int GRAPHICS_MODE_WIDTH;
    int GRAPHICS_MODE_HEIGHT;
    int WINDOW_WIDTH;
    int WINDOW_HEIGHT;
    uint useRotoscope;
    uint useEGA;
    float iTime;
    float worldX;
    float worldY;
    float heading;
    float deadX;
    float deadY;
    // V= CONTEXT-ID#   ( 0=planet surface, 1=orbit, 2=system)         
    // (3 = hyperspace, 4 = encounter, 5 = starport)
    uint game_context; 
    uint alienVar1;
} uniforms;

layout(binding = 15) uniform IconBlock {
    Icon icons[32];
};

layout(binding = 16) uniform sampler2D NavigationTexture;

#include "tables.h"
#include "noise.h"
#include "distance.h"
#include "galaxy.h"
#include "station_stars.h"

void drawMechan( out vec4 fragColor, in vec2 uv )
{
    float time = uniforms.iTime * 0.11;

    float talkPos = float(uniforms.alienVar1) / 50000.0;

    float zoomFactor = 1.0 + noise(vec2(time)) * 0.05 - talkPos; // Adjust the 0.1 value to control the amount of zoom

    // Translate UV coordinates to center
    vec2 centeredUV = uv - vec2(0.5, 0.5);

    // Get depth before zooming
    float depthRep = texture(AlienDepthTexture, uv).r;

    // Scale (zoom) and reproject based on depth
    centeredUV *= zoomFactor - (depthRep / 25.);

    // Translate back
    vec2 zoomedUV = centeredUV + vec2(0.5, 0.5);
    vec4 robot = texture(AlienColorTexture, zoomedUV);

    // Define light position
    vec3 lightPos = vec3(0.33 + talkPos, 0.33, -1.10 - talkPos);
    
    // Calculate the direction from the light to the robot
    vec2 lightDir = normalize(lightPos.xy - uv);
    
    float depth = texture(AlienDepthTexture, zoomedUV).r;
    
    if (depth < 0.4)
    {
        robot.rgba = vec4(0.0);
    }

    vec4 wall = texture(AlienBackgroundTexture, uv);

    // Calculate shadow position
    vec2 shadowPos = uv - 0.5 + lightPos.xy;
    shadowPos /= abs(lightPos.z);

    // Sample the robot texture at the shadow position
    vec4 shadow = texture(AlienColorTexture, shadowPos);
    if(shadowPos.x > 1.0 || shadowPos.x < 0.0 || shadowPos.y < 0.0 || shadowPos.y > 1.0)
    {
        shadow.rgba = vec4(0.0);
    }
    
    // Sample the depth buffer from iChannel1
    float shadowDepth = texture(AlienDepthTexture, shadowPos).r;
    
    if(shadowDepth < 0.4)
    {
        shadow.rgba = vec4(0.0);
    }

    // If the shadow position is within the robot's silhouette, darken the wall
    if (shadow.a > 0.0)
    {
        wall.rgb *= 0.5;
    }

    // Calculate view direction
    vec3 viewDir = normalize(vec3(uv, 0.0) - vec3(lightPos.xy, depth));

    // Calculate reflection direction
    vec3 reflectDir = reflect(viewDir, vec3(lightDir, 0.0));

    // Calculate specular intensity
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 20.0);

    // Reduce specular intensity for dark or green pixels
    float reflectivity = smoothstep(0.2, 0.6, length(robot.rgb - vec3(0.0, 1.0, 0.0)));
    spec *= reflectivity;

    // Add specular intensity to the robot color
    robot.rgb += vec3(0.5) * spec;

    // Pre-multiplied alpha blend robot to the wall as the final output color
    vec4 color = robot * robot.a + wall * (1.0 - robot.a);
    
    // Output to screen
    fragColor = color;
    
    // Define the center of the circle
    vec2 center = vec2(0.52, 1.0 - 0.178);

    // Calculate the distance from the current pixel to the center
    float dist = distance(uv, center);

    // Define the radius of the circle
    float radius = 0.108;

    // Use a step function to create a hard edge
    float circle = 1.0 - step(radius, dist);

    float brightnessAdjustment = float(uniforms.alienVar1) / 1024.0; // Change this value to adjust brightness

    // Calculate the adjusted color
    vec4 adjustedColor = fragColor * vec4(vec3(brightnessAdjustment), 1.0);

    // Blend the adjusted color with the existing color
    fragColor = mix(fragColor, adjustedColor, circle);  
}

vec4 DrawLinePixel(const Rotoscope roto, vec2 uv, float polygonWidth) {
    vec4 pixel;

    float lineX1 = (roto.lineData.x0 + 0.10f) / uniforms.GRAPHICS_MODE_WIDTH;
    float lineY1 = (roto.lineData.y0 + 0.10f) / uniforms.GRAPHICS_MODE_HEIGHT;
    float lineX2 = (roto.lineData.x1 + 0.90f) / uniforms.GRAPHICS_MODE_WIDTH;
    float lineY2 = (roto.lineData.y1 + 0.90f) / uniforms.GRAPHICS_MODE_HEIGHT;

    float a = polygonWidth;
    float one_px = 1.0f / uniforms.WINDOW_WIDTH;
    vec2 p1 = vec2(lineX1, lineY1);
    vec2 p2 = vec2(lineX2, lineY2);

    float d = distance(p1, p2);
    float duv = distance(p1, uv);

    float r = 1.0f - floor(1.0f - (a * one_px) + distance(mix(p1, p2, clamp(duv / d, 0.0f, 1.0f)), uv));

    if (r > 0.0f) {
        pixel = colortable[roto.fgColor & 0xf];
    } else {
        pixel = colortable[roto.bgColor & 0xf];
    }

    return pixel;
}

vec4 DrawFontPixel(const Rotoscope roto, vec2 uv, vec2 subUv) {
    vec4 pixel;

    float fontX = (float(roto.blt_x) + subUv.x) / float(roto.blt_w);
    float fontY = (float(roto.blt_y) + subUv.y) / float(roto.blt_h);

    if(roto.textData.fontNum == 1) {
        // Find the character in our atlas.
        const float fontSpaceWidth = 8.0f * 4.0f;
        const float fontSpaceHeight = 8.0f * 4.0f;

        const float atlasWidth = 448.0f;
        const float atlasHeight = 160.0f;

        uint c = roto.textData.character - 32;
        uint fontsPerRow = 448 / uint(fontSpaceWidth);
        uint fontRow = c / fontsPerRow;
        uint fontCol = c % fontsPerRow;

        float u = fontCol * fontSpaceWidth / atlasWidth;
        float v = fontRow * fontSpaceHeight / atlasHeight;

        u += fontX * (fontSpaceWidth / atlasWidth);
        v += fontY * (fontSpaceHeight / atlasHeight);

        vec4 glyph = texture(FONT1Texture, vec2(u, v));
        pixel = colortable[roto.bgColor & 0xf];
        if(glyph.r > 0.80f) {
            pixel = colortable[roto.fgColor & 0xf];
        }
    } else if (roto.textData.fontNum == 2) {
        // Find the character in our atlas.
        const float fontSpaceWidth = 15.0f * 4.0f;
        const float fontSpaceHeight = 11.0f * 4.0f;

        const float atlasWidth = 840.0f;
        const float atlasHeight = 220.0f;

        uint c = roto.textData.character - 32;
        uint fontsPerRow = 840 / uint(fontSpaceWidth);
        uint fontRow = c / fontsPerRow;
        uint fontCol = c % fontsPerRow;

        float u = fontCol * fontSpaceWidth / atlasWidth;
        float v = fontRow * fontSpaceHeight / atlasHeight;

        u += fontX * (fontSpaceWidth / atlasWidth);
        v += fontY * (fontSpaceHeight / atlasHeight);

        vec4 glyph = texture(FONT2Texture, vec2(u, v));
        pixel = colortable[roto.bgColor & 0xf];
        if(glyph.r > 0.9f) {
            pixel = colortable[roto.fgColor & 0xf];
        }
    } else if (roto.textData.fontNum == 3) {
        // Find the character in our atlas.
        const float fontSpaceWidth = 15.0f * 4.0f;
        const float fontSpaceHeight = 11.0f * 4.0f;

        const float atlasWidth = 840.0f;
        const float atlasHeight = 220.0f;

        uint c = roto.textData.character - 32;
        uint fontsPerRow = 840 / uint(fontSpaceWidth);
        uint fontRow = c / fontsPerRow;
        uint fontCol = c % fontsPerRow;

        float u = fontCol * fontSpaceWidth / atlasWidth;
        float v = fontRow * fontSpaceHeight / atlasHeight;

        u += fontX * (fontSpaceWidth / atlasWidth);
        v += fontY * (fontSpaceHeight / atlasHeight);

        vec4 glyph = texture(FONT3Texture, vec2(u, v));
        pixel = colortable[roto.bgColor & 0xf];
        if(glyph.r > 0.9f) {
            pixel = colortable[roto.fgColor & 0xf];
        }
    }

    return pixel;
}

float rgb2hue(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return abs(q.z + (q.w - q.y) / (6.0 * d + e));
}

bool isGreen(vec3 rgb) {
    float hue = rgb2hue(rgb);
    return hue > 0.32 && hue < 0.34;
}

vec4 DrawSDFSilhouette(const Rotoscope roto, vec2 subUv) {
    vec4 sdf = texture(RACEDOSATLASTexture, subUv);

    if(sdf.r < 0.5)
    {
        return colortable[roto.bgColor & 0xf];
    }
    else
    {
        return colortable[roto.fgColor & 0xf];
    }
}

vec4 DrawNavigationPixel(const Rotoscope roto, vec2 uv, vec2 subUv) {
    float subX = (float(roto.blt_x) + subUv.x) / float(roto.blt_w);
    float subY = (float(roto.blt_y) + subUv.y) / float(roto.blt_h);
    return texture(NavigationTexture, vec2(subX, subY));
}

vec4 DrawRunBitPixel(const Rotoscope roto, vec2 uv, vec2 subUv) {
    vec4 pixel;

    vec4 fragColor;
    vec2 sub;

    float iTime = uniforms.iTime;

    float subX = (float(roto.blt_x) + subUv.x) / float(roto.blt_w);
    float subY = (float(roto.blt_y) + subUv.y) / float(roto.blt_h);

    vec2 iResolution = vec2(float(roto.blt_w), float(roto.blt_h));
    vec2 fragCoord = vec2(subX * iResolution.x, subY * iResolution.y);

    switch (roto.runBitData.tag)
    {
        case 9: // Mechan 9 comms
            {
                //pixel = vec4(1.0, 1.0, 0.0, 1.0); // vec4(unpackUnorm4x8(roto.argb)).bgra;
                drawMechan(pixel, vec2(subX, subY));
            }
            break;
        case 44: // Port-Pic Top 100 pixels
            pixel = texture(PORTPICTexture, vec2(subX, subY * 0.5f));
            if(isGreen(pixel.rgb))
            {
                stationStarsRender(pixel, fragCoord, iTime, iResolution);
            }
            break;
        case 49: // Port-Pic Botton 100 pixels
            pixel = texture(PORTPICTexture, vec2(subX, (subY * 0.5f) + 0.5f));
            break;
        case 141: // First splash
            pixel = texture(LOGO1Texture, uv);
            fragCoord.y = 199.0 - fragCoord.y;
            galaxyRender(fragColor, fragCoord, iTime, iResolution);
            pixel.xyz += fragColor.xyz;
            break;
        case 54:  // Second logo screen
            pixel = texture(LOGO2Texture, uv);
            break;
        case 125:
            sub = vec2(subX / 5.0, subY);
            pixel = DrawSDFSilhouette(roto, sub);
            break;
        case 126:
            sub = vec2(subX / 5.0 + (1.0 / 5.0), subY);
            pixel = DrawSDFSilhouette(roto, sub);
            break;
        case 127:
            sub = vec2(subX / 5.0 + (2.0 / 5.0), subY);
            pixel = DrawSDFSilhouette(roto, sub);
            break;
        case 128:
            sub = vec2(subX / 5.0 + (3.0 / 5.0), subY);
            pixel = DrawSDFSilhouette(roto, sub);
            break;
        case 129:
            sub = vec2(subX / 5.0 + (4.0 / 5.0), subY);
            pixel = DrawSDFSilhouette(roto, sub);
            break;
        default:
            pixel = vec4(1.0, 0.0, 0.0, 1.0); // vec4(unpackUnorm4x8(roto.argb)).bgra;
            break;
    }

    return pixel;
}

void main() {
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    vec2 windowSize = vec2(float(uniforms.WINDOW_WIDTH), float(uniforms.WINDOW_HEIGHT));
    vec2 graphicSize = vec2(float(uniforms.GRAPHICS_MODE_WIDTH), float(uniforms.GRAPHICS_MODE_HEIGHT));
    
    vec2 uv = vec2(pixelPos) / windowSize;

    const float polygonWidth = uniforms.WINDOW_WIDTH / uniforms.GRAPHICS_MODE_WIDTH;

    // Calculate the corresponding position in the smaller texture
    uvec2 src = uvec2(floor(uv * graphicSize));

    // Calculate the index in the smaller texture
    uint srcIndex = src.y * uint(uniforms.GRAPHICS_MODE_WIDTH) + src.x;

    Rotoscope roto = rotoPixels[srcIndex];

    vec2 subUv = (uv * graphicSize) - vec2(src);

    // Pull the pixel from the smaller texture
    vec4 pixel = vec4(unpackUnorm4x8(roto.argb)).bgra;

    if(uniforms.useRotoscope != 0)
    {
        switch(roto.content) {
            #if 0 
            case LinePixel:
                pixel = DrawLinePixel(roto, uv, polygonWidth);
                break;
            #endif
            case TextPixel:
                pixel = DrawFontPixel(roto, uv, subUv);    
                break;
            case RunBitPixel:
                pixel = DrawRunBitPixel(roto, uv, subUv);
                break;
            case NavigationalPixel:
                if((uniforms.game_context == 2 || uniforms.game_context == 3))
                {
                    // System and hyperspace
                    pixel = DrawNavigationPixel(roto, uv, subUv);
                }
                break;
            default:
                break;
        }
    }
    else if(uniforms.useEGA == 0)
    {
        uint c = EGAToCGA[roto.EGAcolor];
        if(subUv.x < 0.5f)
        {
            pixel = CGAPalette[(c >> 2) & 3];
        }
        else
        {
            pixel = CGAPalette[c & 3];
        }
    }

    // Place the pixel in the larger surface
    imageStore(imgOutput, pixelPos, pixel);
}

