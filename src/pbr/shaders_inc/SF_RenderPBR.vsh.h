"#include \"BasicStructures.fxh\"\n"
"#include \"VertexProcessing.fxh\"\n"
"#include \"SF_PBR_Structures.fxh\"\n"
"#include \"SF_RenderPBR_Structures.fxh\"\n"
"\n"
"#include \"VSInputStruct.generated\"\n"
"//struct VSInput\n"
"//{\n"
"//    float3 Pos     : ATTRIB0;\n"
"//    float3 Normal  : ATTRIB1;\n"
"//    float2 UV0     : ATTRIB2;\n"
"//    float2 UV1     : ATTRIB3;\n"
"//    float4 Joint0  : ATTRIB4;\n"
"//    float4 Weight0 : ATTRIB5;\n"
"//    float4 Color   : ATTRIB6; // May be float3\n"
"//    float3 Tangent : ATTRIB7;\n"
"//    uint InstanceID : SV_InstanceID;\n"
"//};\n"
"\n"
"#include \"VSOutputStruct.generated\"\n"
"// struct VSOutput\n"
"// {\n"
"//     float4 ClipPos     : SV_Position;\n"
"//     float3 WorldPos    : WORLD_POS;\n"
"//     float4 Color       : COLOR;\n"
"//     float3 Normal      : NORMAL;\n"
"//     float2 UV0         : UV0;\n"
"//     float2 UV1         : UV1;\n"
"//\n"
"//     float3 Tangent     : TANGENT;\n"
"//     float4 PrevClipPos : PREV_CLIP_POS;\n"
"//     float Height : HEIGHT;\n"
"// };\n"
"\n"
"#ifdef USE_HEIGHTMAP\n"
"cbuffer cbHeightmapAttribs\n"
"{\n"
"    PBRHeightmapAttribs g_HeightmapAttribs;\n"
"}\n"
"Texture2D g_Heightmap;\n"
"SamplerState g_Heightmap_sampler;\n"
"\n"
"float4 sampleBicubic(float v) {\n"
"    float4 n = float4(1.0, 2.0, 3.0, 4.0) - v;\n"
"    float4 s = n * n * n;\n"
"    float4 o;\n"
"    o.x = s.x;\n"
"    o.y = s.y - 4.0 * s.x;\n"
"    o.z = s.z - 4.0 * s.y + 6.0 * s.x;\n"
"    o.w = 6.0 - o.x - o.y - o.z;\n"
"    return o;\n"
"}\n"
"\n"
"float4 textureBicubic(Texture2D tex, SamplerState samplerState, float2 st)\n"
"{\n"
"    int2 texResolution;\n"
"    tex.GetDimensions(texResolution.x, texResolution.y);\n"
"    float2 pixel = 1.0 / float2(texResolution);\n"
"\n"
"    st = st * texResolution - 0.5;\n"
"\n"
"    float2 fxy = frac(st);\n"
"    st -= fxy;\n"
"\n"
"    float4 xcubic = sampleBicubic(fxy.x);\n"
"    float4 ycubic = sampleBicubic(fxy.y);\n"
"\n"
"    float4 c = st.xxyy + float2 (-0.5, 1.5).xyxy;\n"
"\n"
"    float4 s = float4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n"
"    float4 offset = c + float4(xcubic.yw, ycubic.yw) / s;\n"
"\n"
"    offset *= pixel.xxyy;\n"
"\n"
"    float4 sample0 = tex.Sample(samplerState, offset.xz);\n"
"    float4 sample1 = tex.Sample(samplerState, offset.yz);\n"
"    float4 sample2 = tex.Sample(samplerState, offset.xw);\n"
"    float4 sample3 = tex.Sample(samplerState, offset.yw);\n"
"\n"
"    float sx = s.x / (s.x + s.y);\n"
"    float sy = s.z / (s.z + s.w);\n"
"\n"
"    return lerp(    lerp(sample3, sample2, sx),\n"
"                    lerp(sample1, sample0, sx),\n"
"                    sy);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#if USE_INSTANCING\n"
"StructuredBuffer<PBRInstanceAttribs> instanceBuffer : register(t1);\n"
"#endif\n"
"\n"
"#if USE_TERRAINING\n"
"cbuffer cbTerrainAttribs\n"
"{\n"
"    PBRTerrainAttribs g_Terrain;\n"
"}\n"
"#endif\n"
"\n"
"#ifndef MAX_JOINT_COUNT\n"
"#   define MAX_JOINT_COUNT 64\n"
"#endif\n"
"\n"
"cbuffer cbFrameAttribs\n"
"{\n"
"    PBRFrameAttribs g_Frame;\n"
"}\n"
"\n"
"cbuffer cbPrimitiveAttribs\n"
"{\n"
"#if PRIMITIVE_ARRAY_SIZE > 0\n"
"    PBRPrimitiveAttribs g_Primitive[PRIMITIVE_ARRAY_SIZE];\n"
"#else\n"
"    PBRPrimitiveAttribs g_Primitive;\n"
"#endif\n"
"}\n"
"\n"
"\n"
"#if PRIMITIVE_ARRAY_SIZE > 0\n"
"// PRIMITIVE_ID is defined by the host as gl_DrawID or gl_DrawIDARB\n"
"#   define PRIMITIVE g_Primitive[PRIMITIVE_ID]\n"
"#else\n"
"#   define PRIMITIVE g_Primitive\n"
"#endif\n"
"\n"
"\n"
"#if MAX_JOINT_COUNT > 0 && USE_JOINTS\n"
"cbuffer cbJointTransforms\n"
"{\n"
"    float4x4 g_Joints[MAX_JOINT_COUNT];\n"
"#if COMPUTE_MOTION_VECTORS\n"
"    float4x4 g_PrevJoints[MAX_JOINT_COUNT];\n"
"#endif\n"
"}\n"
"#endif\n"
"\n"
"float4 GetVertexColor(float3 Color)\n"
"{\n"
"    return float4(Color, 1.0);\n"
"}\n"
"\n"
"float4 GetVertexColor(float4 Color)\n"
"{\n"
"    return Color;\n"
"}\n"
"\n"
"void main(in  VSInput  VSIn,\n"
"          out VSOutput VSOut)\n"
"{\n"
"    // Warning: moving this block into GLTF_TransformVertex() function causes huge\n"
"    // performance degradation on Vulkan because glslang/SPIRV-Tools are apparently not able\n"
"    // to eliminate the copy of g_Transforms structure.\n"
"    float4x4 Transform = PRIMITIVE.Transforms.NodeMatrix;\n"
"\n"
"#if COMPUTE_MOTION_VECTORS\n"
"    float4x4 PrevTransform = PRIMITIVE.PrevNodeMatrix;\n"
"#endif\n"
"\n"
"#if MAX_JOINT_COUNT > 0 && USE_JOINTS\n"
"    if (PRIMITIVE.Transforms.JointCount > 0)\n"
"    {\n"
"        // Mesh is skinned\n"
"        float4x4 SkinMat =\n"
"            VSIn.Weight0.x * g_Joints[int(VSIn.Joint0.x)] +\n"
"            VSIn.Weight0.y * g_Joints[int(VSIn.Joint0.y)] +\n"
"            VSIn.Weight0.z * g_Joints[int(VSIn.Joint0.z)] +\n"
"            VSIn.Weight0.w * g_Joints[int(VSIn.Joint0.w)];\n"
"        Transform = mul(SkinMat, Transform);\n"
"\n"
"#       if COMPUTE_MOTION_VECTORS\n"
"        {\n"
"            float4x4 PrevSkinMat =\n"
"                VSIn.Weight0.y * g_PrevJoints[int(VSIn.Joint0.y)] +\n"
"                VSIn.Weight0.x * g_PrevJoints[int(VSIn.Joint0.x)] +\n"
"                VSIn.Weight0.z * g_PrevJoints[int(VSIn.Joint0.z)] +\n"
"                VSIn.Weight0.w * g_PrevJoints[int(VSIn.Joint0.w)];\n"
"            PrevTransform = mul(PrevSkinMat, PrevTransform);\n"
"        }\n"
"#       endif\n"
"    }\n"
"#endif\n"
"\n"
"#if USE_VERTEX_NORMALS\n"
"    float3 Normal = VSIn.Normal;\n"
"#else\n"
"    float3 Normal = float3(0.0, 0.0, 1.0);\n"
"#endif\n"
"\n"
"#if USE_HEIGHTMAP\n"
"\n"
"    #if USE_INSTANCING\n"
"        PBRInstanceAttribs instance = instanceBuffer[VSIn.InstanceID];\n"
"        Transform = mul(instance.NodeMatrix, Transform);\n"
"        float2 adjustedUV = VSIn.UV0 * float2(instance.HeightmapAttribs.ScaleX, instance.HeightmapAttribs.ScaleY) + float2(instance.HeightmapAttribs.OffsetX, instance.HeightmapAttribs.OffsetY);\n"
"    #else // USE_INSTANCING\n"
"        float2 adjustedUV = VSIn.UV0 * float2(g_HeightmapAttribs.ScaleX, g_HeightmapAttribs.ScaleY) + float2(g_HeightmapAttribs.OffsetX, g_HeightmapAttribs.OffsetY);\n"
"    #endif // USE_INSTANCING\n"
"\n"
"    #if USE_TERRAINING\n"
"        adjustedUV += float2(g_Terrain.textureOffsetX, g_Terrain.textureOffsetY);\n"
"    #endif\n"
"\n"
"    float height = textureBicubic(g_Heightmap, g_Heightmap_sampler, adjustedUV).r;\n"
"    float3 adjustedPos = VSIn.Pos + float3(0.0, height, 0.0);\n"
"    VSOut.Height = height;\n"
"#else\n"
"    float3 adjustedPos = VSIn.Pos;\n"
"#endif // USE_HEIGHTMAP\n"
"\n"
"    GLTF_TransformedVertex TransformedVert = GLTF_TransformVertex(adjustedPos, Normal, Transform);\n"
"    VSOut.ClipPos = mul(float4(TransformedVert.WorldPos, 1.0), g_Frame.Camera.mViewProj);\n"
"\n"
"#if COMPUTE_MOTION_VECTORS\n"
"    GLTF_TransformedVertex PrevTransformedVert = GLTF_TransformVertex(VSIn.Pos, Normal, PrevTransform);\n"
"    VSOut.PrevClipPos  = mul(float4(PrevTransformedVert.WorldPos, 1.0), g_Frame.PrevCamera.mViewProj);\n"
"#endif\n"
"\n"
"    VSOut.WorldPos = TransformedVert.WorldPos;\n"
"\n"
"#if USE_VERTEX_COLORS\n"
"    VSOut.Color    = GetVertexColor(VSIn.Color);\n"
"#endif\n"
"\n"
"#if USE_VERTEX_NORMALS\n"
"    VSOut.Normal   = TransformedVert.Normal;\n"
"#endif\n"
"\n"
"#if USE_TEXCOORD0\n"
"    VSOut.UV0      = VSIn.UV0;\n"
"#if USE_TERRAINING\n"
"#if !defined(USE_HEIGHTMAP) || !defined(USE_INSTANCING) && !defined(USE_TEXCOORD1)\n"
"    #error \"Height map, instancing and texcoord1 must be enabled\"\n"
"#endif\n"
"    int instanceX = VSIn.InstanceID % 61;\n"
"    int instanceY = VSIn.InstanceID / 61;\n"
"    float2 megaUV = VSIn.UV0 * float2(instance.HeightmapAttribs.ScaleX, instance.HeightmapAttribs.ScaleY) + float2(instance.HeightmapAttribs.OffsetX, instance.HeightmapAttribs.OffsetY);\n"
"\n"
"    #if USE_TERRAINING\n"
"        megaUV += float2(g_Terrain.textureOffsetX, g_Terrain.textureOffsetY);\n"
"    #endif\n"
"\n"
"    VSOut.UV2 = VSIn.UV0;\n"
"    VSOut.UV0 = frac(megaUV * 9.0);\n"
"    VSOut.UV1 = megaUV;\n"
"\n"
"#endif // USE_TERRAINING\n"
"#endif // USE_TEXCOORD0\n"
"\n"
"#if USE_TEXCOORD1 && !USE_TERRAINING\n"
"    VSOut.UV1      = VSIn.UV1;\n"
"#endif\n"
"\n"
"#if USE_VERTEX_TANGENTS\n"
"    VSOut.Tangent  = normalize(mul(VSIn.Tangent, float3x3(Transform[0].xyz, Transform[1].xyz, Transform[2].xyz)));\n"
"#endif\n"
"\n"
"#ifdef USE_GL_POINT_SIZE\n"
"#   if defined(GLSL) || defined(GL_ES)\n"
"        // If gl_PointSize is not defined, points are not rendered in GLES\n"
"        gl_PointSize = g_Frame.Renderer.PointSize;\n"
"#   else\n"
"        VSOut.PointSize = g_Frame.Renderer.PointSize;\n"
"#   endif\n"
"#endif\n"
"\n"
"#if PRIMITIVE_ARRAY_SIZE > 0\n"
"    VSOut.PrimitiveID = PRIMITIVE_ID;\n"
"#endif\n"
"}\n"
